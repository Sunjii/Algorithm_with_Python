'''
1924 : 1 2를 뺀다
1231234 : 1 2 1 를 뺀다
--> 작은 숫자부터 빼면 되는구나! No
4177252841 : 4 1 2 2 를 뺀다.
*왜 뒤에 1은 남기는가? 775841 을 만들기 위해서. 앞자리가 제일 큰 숫자가 오도록

- 알고리즘 설계
1. 앞자리에서 시작하여 담는다.
2. 지금 담으려는 것보다 작은 것은 도로 뺀다.
3. 뺄 수 있는 제한에 도달하면 정지
-- 큰 수가 앞자리에, 작은 수는 뒷자리에 오도록 한다.
4 1 
4 1 7 에서 아직 뺄 수 있는 여유가 있으므로 4 1을 뺀다. 7
7 7
7 7 2 통과
7 7 2 5 5가 2보다 크고 여유가 있으므로 2를 뺀다. 775 여기서 멈춘다. 더 이상 뺄 필요가 없음 (775가 제일 크다는 뜻)
7 7 5 2
7 7 5 2 8 8을 앞에 두는것이 유리함. 7758
775841 : 여기서 끝나는 이유는 뺄 수 잇는 k가 전부 소진되었기 때문

98765 k=2인 경우
9
98
987
9876 : 6 제거
9875 : 5 제거
최종 : 987

- 알고리즘 구현
1. 주어진 숫자로부터 하나씩 꺼낸다. 단, 모아둔 것 중 지금 등장한 것보다 작은 것을 뺀다.(맨 오른쪽)
2. 이렇게 모은 숫자를 자릿수를 맞추어 반환
3. 아직 k가 남은 경우에는 끝부분을 자른다

- 복잡도
1. 브루트 포스 : n자리 숫자라면 조합에 의해 무지막지하다
2. 위 방식 : O(n) 

탐욕법이 통하는 이유
앞 단계에서 선택이 이후 단계의 선택에 의한 solution의 최적성(optimality)에 영향을 주지 않는다!!
'''


def solution(number, k):
    collected = [] # 빈 list. 숫자를 모을 목적임. 문자열은 왜 안 쓰나? -> immutable 하므로..
    # mutable? immutable?
    
    for i, num in enumerate(number): # O(n)
        while len(collected) > 0 and collected[-1] < num and k > 0: # O(1)
            # 리스트의 마지막 숫자가 현재 선택된 숫자인 num보다 작다면, 그리고 k에 여유가 있다면
            collected.pop()
            k -= 1
        if k == 0:
            collected += list(number[i:]) # k가 더 없으므로 남은 숫자들을 모두 붙여서 완성
            break
        collected.append(num) # 붙인다
    
    collected = collected[:-k] if k > 0 else collected # 뒤에서 k개의 숫자를 제거함
    answer = ''.join(collected)
    return answer